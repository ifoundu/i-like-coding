# 学习心得 | 函数式编程思想初探 - 进阶课第8节(部分)


为了解决在理解检索通讯录的lookUP函数过程中遇到的问题，去找了 JS 进阶课中相关函数式编程的内容来看。
至少找到两段相关视频：  
 - 进阶课第8节: 时段20：43-21：00(函数式编程思想初探) + 时段21:00-21:14(ramda) 
   (徐老师在视频里说这是“初探”。)
 - 进阶课第9节：时段20：22-20：45(函数式编程思想正传，暂且这么说) 

这一次的心得整理，针对的是“函数式编程思想初探”。 看的时候把这一段按顺序做了[笔记](https://github.com/ifoundu/i-like-coding/blob/master/JS进阶/8_2043-2114_函数式编程初探.md)。但为了方便自己记忆，又再理清一下线索或者说思路。因为不熟悉，整个过程需要的时间多了很多。


## 总结
对老师分析内容的总结，也是写这篇心得的思路。

老师从函数的定义方式和调用方式两方面，为我们分析了函数式编程思想的核心方向。过程中的举例是最简单的、两个参数相加函数的演进过程。


### 假设有一个需求，需要任意两个数相加，即 `x + y`。

### 1. 定义方式：  
   
   - 非函数式：(x, y) 
   - 函数式编程（在参数上的柯里化）：(x)(y)    
     
### 2. 调用方式：  
   定义方式决定了可以采用的调用方式
   - `直接调用` ：在主文件里定义和调用
   - `引包` ：
     - `引入对象`：整个包 lib 文件
     - `引入函数`：包文件中的某个函数

#### 根据定义方式，分析过程的代码例子可以分为：

| 代码例 | 非函数式定义: (x, y)| 数据 |定义 + 调用方式 |
| :-: | :--: | -- | - |
| 例1 | x + y | 都是动态 | 定义函数体 + 直接调用 |
| 例2 | x + y | （同上） | 定义函数体 + 引包调用 |
| 例3 | x + 1 | x 为动态, y 为固定值 | 定义函数体 + 引包调用 |
| 例4 | x + 2 | （同上） | 定义函数体 + 引包调用 |
  
    
|代码例| 函数式定义：(x)(y)| 数据 | 定义 + 调用方式 |
| :-: | :--: | -- | - |
| 例5 | x + y | 都是动态 | 定义(根）函数体 + 引包调用 |
| 例6 | x + 1 | x 为动态, y 为固定值 | 简化定义函数 + 直接调用 |
| 例7 | x + 1 | （同上） | 简化定义函数 + 引包调用: 反例 |
| 例8 | x + 2 | （同上） | 简化定义函数 + 直接调用 |


## 分析过程

### 例 1  非函数式定义 `x + y` 和 直接调用
在主文件 app.js 里，定义函数:
```javascript
// app.js
var express = require('express');
var app = express ();

function add(x, y) {    // 定义函数 add
  return x + y;
}

var value = add (1, 2); // 调用函数

console.log(value);

module.exports = app;
```
老师提到，这是传统型的编程，而且是里面较好的一种方式。  
这时候，函数 add 的定义和调用是发生在同一个文件里。

### 例2  非函数式定义 `x + y` 和 引包调用
在包文件里 定义函数 和 引包调用  

第一步，把函数定义在独立的包文件里，导出去；文件命名为 lib.js 。  
第二步，在 app.js 中引入再调用。    
  
具体如下：  

```javascript
// 新建包文件 lib.js 


function add(x, y) {     // 定义函数 add
  return x + y;
}


module.exports = add;    // 导出
```

```javascript
// app.js

var express = require ('express');
var app = express();
var add = require(./lib); // 引包（包中的 add 函数）

var value = add(1, 2);    // 调用

module.export = app;

```
“add 像一个工具函数。”   通过引包的方式调用，增强复用的性能。

调用时，还可以这样:

```javascript
...

var add = require('./lib');

add(2,3);   //简化一下调用表达式
add(4,7);

...
```

### 例 3 非函数式定义 `x + 1` 和 引包调用
当我们只想要，传入的任意参数自增 1 。比如传入这些 6、9、10,
则调用表达式如下：  
```javascript
add(6, 1);
add(9, 1);
add(10, 1);
```
自增 1 可以归为`两数相加中的有一个数固定为 1`。为了简化对这一类的计算，再定义一个 `专门自增 1 ` 的函数 inc。

```javascript
// lib.js
function add(x, y) {
  return x + y;
}

function inc(x) {     // 定义“专门自增 1 ”的函数 inc
  return x + 1;
}

module.exports = { add, inc };     // 导出一个对象
```

之前只在包文件中定义了一个函数，现在定义了两个，而且两个都要调用。  
于是，导出时，用了一个对象`{ add, inc }`。对象里面的两个属性就是将要被调用的两个函数 add 和 inc。  
对应的，通过引入`整个包文件`再调用函数，即，把引入的变量名改成 lib 文件名;
并通过`调用对象方法`的方式，调用包文件内的函数。

> 在这里，出下戏：是不是整个 js 文件就是一个对象呢。看来是的，再确定。

```javascript
// app.js
var express = require('express');
var app = express ();
var lib = require('./lib');   // add 改成 lib，引入整个包

// 调用对象方法
lib.add(3, 4);    // 非 +1 的计算 ；
lib.inc(6);       // 调用 “专门自增 1 ” 的函数 inc
lib.inc(9);
lib.inc(10);

module.exports = app;
```
### 例 4 非函数式定义 `x + 2` 和 引包调用  

按这样的方式一直下去，如果要简化 “自增 n ”，需要增加 n 个函数。  
以 “ 自增 2 ” 为例：  

```javascript
// lib.js
function add(x, y) {
  return x + y;
}

function inc(x) {
  return x + 1;
}

function inc2(x) {     // 增加“自增 2 ”的函数 inc2
  return x + 2;
}

module.exports = { add, inc, inc2 };     //再导出一个 inc2
```


```javascript
// app.js
var express = require('express');
var app = express();
var lib = require('./lib');   

lib.add(3, 4);       // 任意两数相加
lib.inc(6);          // 任意数自增 1
lib.inc(9);
lib.inc2(10);        // 调用 inc2 ，进行“自增 2 ” 

module.exports = app; 

// [在视频中 inc2 原是 inc,有讲解没问题; 在文本上为了衔接，我自己改成 inc2]
```


把老师说的话自己“翻译”了一下：  
在这个例 2 中，任意两数相加，和任意一个数自增 1 ，可以调用`lib.add` 或 `lib.inc` 最适合的函数各司其职。
但是，还会有自增 2 ， 自增 3...“需求总是很多”，光是跟着“自增 n”这样的需求逐一增加函数，就要无限增加下去了。
说到底，还是两数相加，  
不管是`lib.add(3, 4)`，或是这里`lib.inc(6)。`  
这样的应对方式，可以用什么方式简化吗?

------------

## ----- 以下，函数式编程的内容来了。-----
这 4 个非函数式例子的变化，是老师在讲课时的一整个演进过程。  
这些函数虽然可以复用，但是如果用函数式改进，还有很大空间，特别是当计算的范围超过两数相加。  

函数式很灵活。`任意两数相加`， 和 `任意自增 n`，可以定义一样的`根函数`，因为在代码上已经是很简化了; 如果要在自增时简化，只需要在调用时进行。 

### 例5 函数式定义 `x + y` 和 引包调用
定义`根函数`:
```javascript
// lib.js
function add(x) {
  return function(y) {
    return x + y;
  }
}

module.exports = add; // 导出 add
``` 

用 return 跳转语句，使外层函数 function(x) 返回一个内部函数 function(y)。也就是说，第一次调用，传入了一个参数 x 后， add(x) 返回的结果，依然是一个函数：

```javascript
function(y) {
  return x + y;
}
```

那么，`add()` 只是变成了它的内部函数。再调用一次，即用`add(x)()`时，传入 y 。 
因此，在函数式编程里，add() 指代的很可能不是一个具体值，而是代表一个函数。
    
这是`柯里化`理念实现的例子。应该是最简单最能说明其根本的例子了吧。
徐老师说：
> 柯里化的目的是为了让所有代码都能写得...（柯里）他认为函数如果能只接收一个参数就够了。  

> “`函数式编程`有一个`很重要的基点`，就是希望整个`函数设计`得应该都是`柯里化`的。” 
（这是在后面 ramda 那段视频里讲的。）


在上面的非函数式定义中，为了最简化地处理 `x + y` 和 `x + 1` ，分别定义了不同的函数进行调用。而为了 `x + n` ， 可能要定义 n 个函数。  
参数柯里化之后，根函数的功能增加，形式进而简化了。调用时，稍做点变化就可以。

接下来，根据非函数式的几个运用角度，用函数式再走一遍，看看是怎么样的调用。

先看下，当`x + y`时，调用是怎么进行的？   

```javascript
// app.js
var express = require('express');
var app = express();
var add = require('./lib');   // 引入 add 

add(1)(2);  // 调用
add(3)(4);  // - 两个任意数相加
add(1)(3);  // - 自增1
add(1)(4);  // - 自增1

module.exports = app;
```

样子看上去，只是(x, y) 变成了 (x)(y)。
在这里我有一点自己的感受：
`(x, y)可以看做一个值。`
这个值像坐标系上的点，由两个数字绑定组成，是一种复合的状态。也就是说，这个状态是`两个数字都确定后才确定的`，因此也像一个`排列`。`排列就像一个对象类型`,其中的数字是对象的属性。(x, y)的外形是{}，或是(),只是一种方便沟通的通用符号。或者说，是在调用时，换成了()。本质上，(x, y)里的两个数字，确定了一个对象，对应一个具体情况。向(x, y)里传入 x 和 y 并调用，是输入一个具体情况，传入了一个对象。也就是说，实际上，传入的不是相互独立的 x 和 y 。
`柯里化参数 x 和 y 后，对 x 和 y 的调用相互独立，才是对一个具体对象的属性 x 和 y 的分开传值。`  
那么，我们就不用面对那么多的具体情况。  
就像排列 (x, y) 被拆开成 x 和 y 两个元素。同时有 10 个 x 和 10 个 y，一共是 20 个值; 但是，它们组成的排列数量是很多的（我得去补数学了），即使我们人工挑选出 x + 1 和 1 + y 最终是同样的结果。    

也像是，在独立后的 x 和 y 面前，xiaoming 对象的各种属性被拆开，无数个 xiaohong、xiaohua的对象数据跑过来，也拆开成属性分开传入函数。
总之，简化了定义函数上的“负担”。  
但是，当所有的数据都通过同一个根函数来处理，所有的计算通集中了，这个函数本身的负担，会不会反而加重了呢？
（就先当是我脑补的吧。）     

### 例 6 函数式简化定义`x + 1` 和 直接调用 

从 例 5 的调用中，再分离出 `x + 1`的情况，（简化地）定义一个`专门自增 1`的函数。  

```javascript
// app.js
var express = require('express');
var app = express();
var add = require('./lib');   

add(1)(2);     

var inc = add(1);      // 直接用`调用表达式`简化定义一个函数    

inc(2);                // 调用 inc 传入 2， 实现 1 + 2

inc(3);
inc(4);

module.exports = app;
```
徐老师说：
>  就这两个简简单单的代码，带来的思想就完完全全不一样。
inc 调了一个 add ，传了一个 1 ，得到一个函数。以后我得到一个 inc 就知道了，就可以搞定了（ + 1 ）。  
也就是说，根本不 care inc函数内部到底是什么东西。我只知道 inc 自动会 + 1。这就是思想。  

如果回头看`非函数式`建立包文件的用意时，可以发现，包文件是用来放工具函数的。而非函数式的函数都是`函数实体`，比如，

```javascript
function inc(x) {
  return x + 1;
}
```

对应的，函数式后，函数的简化定义是这样的调用表达式：  

```javascript
var inc = add(1); 
```
### 例 7 函数式简化定义 `x + 1` 和 引包调用
那还要把这样的`简化函数`放到包文件里面去吗？看一下小徐老师尝试的例子。  
在包文件里定义 inc 并导出：
```javascript
// lib.js
function add(x) {
  return function(y) {
    return x + y;
  }
}

var inc = add(1);      // 在 lib 里定义 inc

module.exports = { add, inc }; // 导出 对象，导出 inc
```
引包，再调用函数 inc：
```javascript
// app.js
var express = require('express');
var app = express();
var lib = require('./lib');    // 引入 lib 

lib.inc(2);                    // “调用方法”的形式调用包文件里的 inc
lib.inc(3);
lib.inc(4);

module.exports = app;
```

对比一下，例 6 在主文件里利落地调用了inc(2)、inc(3)。  
而这里把`var inc = add(1);`放到包文件里再引包调用，等于“绕了个大弯”，  
最终目的是达到了，过程却繁琐了，效率下降了，结果就是“吃力不讨好”。 这个结果的正面意义是，  
`函数式编程更简单，定义一个根函数放在包文件，之后，其他的简化定义和调用，都可以在主文件里完成`。

### 例 8 函数式简化定义 `x + 2` 和 直接调用
关于`自增 n`:
非函数式里，接着还尝试定义 `自增 2`的函数，虽然结论是这样下去，即使简便一点，但是需要定义 n 个 `自增 n`的函数。  
在函数式里，根函数已经柯里化，因此，定义函数（体）这一步已经简化。如果像`var inc = add(1)`这样简单的，用调用表达式`add(1)`定义一个`隐形函数体`的函数，也会比`非函数式`简单。

```javascript
// app.js
var add = require('./lib');    // 引入 add 

var inc = add(1);     // +1
var inc2 = add(2);    // +2 
add(3)(4);

module.exports = app;
```

-------------

函数式用一个根函数，“解决了所有问题（徐老师说的）”。   

完胜 ！ 至少从代码上是这样 ！ 





