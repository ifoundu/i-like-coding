## 函数式编程分析之正传

## 柯里化

```javascript
function add(x,y) {
  return x+y;  
}

add(1,2);
```

curry化的概念很简单：  
只传递给函数一部分参数来调用它，让它`返回一个函数`去`处理剩余的参数`。

```javascript
function add(x) {
  return function (y) {     //返回一个函数，处理剩余函数
    return x+y;
  }
}

add(1)(2);
```

## 函数合成（compose）
![functionCompose.jpg](./images/functionCompose.jpg)
( x通过 f ,得到 y 值 )  

```javascript
function addOne(x) {
  return x + 1;
}

function addTwo(x) {
  return x + 2;
}

function add(f,g) {
  return function (x) {
    return f(g(x));       // 被 g(x) 先处理了一下;g 是 addTwo
  }
}

add(addOne, addTwo)(1); // 4
```
add(addOne, addTwo)输出了一个函数。  

如果把这些函数都屏敝掉，通过一个库的方式引进来：
```javascript
// 【只看到调用表达式】
 add(addOne, addTwo)(1);
```
这样调用函数很奇怪？都不用调到参数的？也就是说，调用了一个add函数，传了两个函数给它再给了个 1 ，然后两个函数都不带参数的，也就是什么都没给它，它就执行了。就像`app.use('/',index);`怎么什么都没给它，它就有参数了？怎么传给它的？  
把add的实现屏敝掉，不就是  add(addOne, addTwo)`这样吗？  
调用add，接着addOne,addTwo整个过程就实现了。实际上预定了过程，诠释了一句话，  
`函数式编程定义过程`。  

```javascript
function (x) {
  return f(g(x));
}
```
`add` 什么都没做，只是帮你返回了一个 function 。整个f里面，把整个过程预制好了。`add(addOne,addTwo)`简单一句话,已经建立了整套代码执行的流程。有了这样一套流程，你再给它一个参数，它自己知道怎么去做这件事。  
换算到`app.use('/',index)`也是一样的，JS 代码、函数式编程的代码，不需要显式地塞参数进去。因为只要大家都遵循一种函数式编程的（方式）。  
因为大家都知道函数式编程就是定义过程。你先得到一个过程，那么传参这件事其实就是 `app.use` 里面你干的这件事情。  
```javascript
function addOne(x) {
  return x + 1;
}

function addTwo(x) {
  return x + 2;
}

add(addOne, addTwo)(1);
```
我们很明白 addOne,addTwo，即使是你定义的函数，你（还是）需要一个 x 。但是在调用过程中，没有显式地给它一个参数，但 add 这个函数 `add(addOne, addTwo)它很明白知道怎么把它接收到的 (1) 参数给到 addOne,addTwo,然后把整个过程计算。这就是`函数式编程思想`。这就叫作`定义过程`。（20:36）  
【`用函数的执行把过程像流程一样固定下来`，传参进入，流程会自动执行，（中间包括自动判断往哪个分支走）。】  
  
拿到这个值，就像个流水线，整个流水线铺好了，剩下的只需要给它一个参数，这就解释了，在 JS 代码里总是有这么多奇怪的代码。【app.use这类调用表达式】Java,Ruby都是显式地传参。  
假如函数都是 addOne(1) 这么调的，这个世界就很美好了嘛。  
【以下反例】  
```javascript
function addOne(x) {
  return x + 1;
}

function addTwo(x) {
  return x + 2;
}

// 以下不一样
var value = addOne(1);    
addTwo(value);           
```
如果这么写，这个代码就是一次性买卖，没有办法复用，还要照顾到整个过程。因为需要知道 addOne 是+1的，addTwo 是+2的，拿到值后再手动地填来填去。很容易出错。假如能`在进行计算之前，先把过程定义好`，
```javascript
function add(f,g) {
  return function (x) {
    return f(g(x));       
  }
}
```
这就是定义过程。有了这个过程，先 g(f(x)) 或 f(g(x))在某种意义上，没有任何问题。因为都是加法。先`+1`或先`+2`，都没有问题。加法的交换律本身没有问题。计算复杂了之后，这么交换可能出问题。  
那么，问题来了，到底应先执行 g 还是 f ? 有没有一种原则？ 在这里是用 f(g(x))。  
(学过编程的同学应该知道，)  
```javascript
if(x === y || x !== 3 !! x === 4)
```
这里先执行哪个?先执行左边。  
在最早的C语言，先执行是的最右边。形成了一个传统。  
在写函数式编程的时候，从某种意义上也是一样。也不是在这个例子里，可以先执行 g ，从(f,g)的右边开始。  
但是，中间件，上次说可以按（从左到右）顺序写，那岂不是先执行后面再执行前面？  
```javascript
app.use(logger('dev'),bodyParser.json(),bodyParser.unlencoded({ extended: false}));
```
但这不一样。只是用这种方式解释一种函数编程的方式。虽然app.use也是一种函数式编程的方式。app.use的基理跟设计这个 add 函数的基理不一样。所以在例子里，先f(g(x))是ok的，是公认的。因为它本身是一个`独立的个体`。  

```javascript
function add(f,g) {
  return function (x) {
    return f(g(x));       
  }
}
```

如果抛掉（以上）代码的详细执行，也许add是从别的地方引过来的，比如 `var add = require('add')`，看到 `add(addOne,addTwo)`，传给它两个函数，这种就不要有陌生感。觉得怎么没有参数。 add 内部一定会帮你把参数传给（里面两个函数）。如果代码能写得这么简单，整个过程就很舒服。  

另，app.use里的参数要看doc文档写参数。【Q:还不明白】